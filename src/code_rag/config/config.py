"""Configuration management for the code-rag tool."""

import os
from pathlib import Path

from dotenv import load_dotenv

DEFAULT_CONFIG = """# Configuration for code-rag
# This file is automatically generated. Modify as needed.

# Embedding model to use for generating vector embeddings
# Options:
# - nomic-ai/CodeRankEmbed (Recommended for code)
# - text-embedding-3-small (Requires OPENAI_API_KEY)
CODE_RAG_EMBEDDING_MODEL=nomic-ai/CodeRankEmbed

# Database type: 'chroma' or 'qdrant'
CODE_RAG_DATABASE_TYPE=chroma

# Database path (optional, defaults to OS-specific cache directory)
# Windows: %LOCALAPPDATA%\\code-rag
# macOS: ~/Library/Caches/code-rag
# Linux: ~/.cache/code-rag
# CODE_RAG_DATABASE_PATH=

# Chunk size in characters for splitting files
CODE_RAG_CHUNK_SIZE=1024

# Batch size for processing documents
CODE_RAG_BATCH_SIZE=32

# Whether to include file headers in chunks (true/false)
CODE_RAG_INCLUDE_FILE_HEADER=true

# Whether to exclude test files from indexing (true/false)
CODE_RAG_EXCLUDE_TESTS=false

# Additional ignore patterns (comma-separated list)
# Examples: *.log,*.tmp,custom_ignore_dir/
CODE_RAG_ADDITIONAL_IGNORE_PATTERNS=

# Whether reranking is enabled (true/false)
CODE_RAG_RERANKER_ENABLED=false

# Reranker model to use
CODE_RAG_RERANKER_MODEL=mixedbread-ai/mxbai-rerank-xsmall-v1

# Type of reranking to perform
CODE_RAG_RERANKER_MULTIPLIER=2

# Security / Verification
CODE_RAG_VERIFY_CHANGES_WITH_HASH=true

# Shared Embedding Server
# Enables reusing the model across multiple calls to save memory
CODE_RAG_SHARED_SERVER=true
CODE_RAG_SHARED_SERVER_PORT=8199
"""


class Config:
    """Configuration handler for the code-rag application."""

    def __init__(self):
        """Initialize configuration from environment variables or defaults."""
        self._load_config_files()
        self.embedding_model = os.getenv(
            "CODE_RAG_EMBEDDING_MODEL", "nomic-ai/CodeRankEmbed"
        )
        self.database_type = os.getenv("CODE_RAG_DATABASE_TYPE", "chroma")

        # Use cache directory if not explicitly set
        if "CODE_RAG_DATABASE_PATH" in os.environ:
            self.database_path = os.getenv("CODE_RAG_DATABASE_PATH")
        else:
            self.database_path = self._get_default_database_path()

        self.chunk_size = self._get_int_env("CODE_RAG_CHUNK_SIZE", 1024)
        self.batch_size = max(1, self._get_int_env("CODE_RAG_BATCH_SIZE", 32))

        # Chunking configuration
        self.include_file_header = os.getenv(
            "CODE_RAG_INCLUDE_FILE_HEADER", "true"
        ).lower() in ("true", "1", "yes")
        self.exclude_tests = os.getenv("CODE_RAG_EXCLUDE_TESTS", "false").lower() in (
            "true",
            "1",
            "yes",
        )

        # Additional ignore patterns (comma-separated)
        additional_ignore_str = os.getenv("CODE_RAG_ADDITIONAL_IGNORE_PATTERNS", "")
        self.additional_ignore_patterns = [
            pattern.strip()
            for pattern in additional_ignore_str.split(",")
            if pattern.strip()
        ]

        self._sanitize_chunk_defaults()

        # Reranker configuration
        self.reranker_enabled = os.getenv(
            "CODE_RAG_RERANKER_ENABLED", "true"
        ).lower() in ("true", "1", "yes")
        self.reranker_model = os.getenv(
            "CODE_RAG_RERANKER_MODEL", "cross-encoder/ms-marco-MiniLM-L-6-v2"
        )
        self.reranker_multiplier = int(os.getenv("CODE_RAG_RERANKER_MULTIPLIER", "2"))

        # Logging configuration
        self.log_level = os.getenv("CODE_RAG_LOG_LEVEL", "INFO").upper()

        # Incremental indexing configuration
        self.reindex_debounce_minutes = self._get_int_env(
            "CODE_RAG_REINDEX_DEBOUNCE_MINUTES", 10
        )
        self.verify_changes_with_hash = os.getenv(
            "CODE_RAG_VERIFY_CHANGES_WITH_HASH", "true"
        ).lower() in ("true", "1", "yes")

        # Model idle timeout configuration (in seconds)
        # Default: 1800 seconds (30 minutes)
        self.model_idle_timeout = self._get_int_env("CODE_RAG_MODEL_IDLE_TIMEOUT", 1800)

        # Shared embedding server configuration
        # When enabled, MCP instances share a single model via HTTP server
        # Server auto-starts on demand and auto-terminates when idle
        self.shared_server_enabled = os.getenv(
            "CODE_RAG_SHARED_SERVER", "true"
        ).lower() in ("true", "1", "yes")
        self.shared_server_port = self._get_int_env("CODE_RAG_SHARED_SERVER_PORT", 8199)

    def _load_config_files(self) -> None:
        """
        Load configuration from config files in precedence order.

        1. Custom config file (CODE_RAG_CONFIG_FILE)
        2. Current directory (code-rag.config)
        3. User config (~/.config/code-rag/config) - Auto-created if missing
        """
        paths_to_check = []

        # 1. Direct path via env var (highest file priority)
        if custom_path := os.getenv("CODE_RAG_CONFIG_FILE"):
            paths_to_check.append(Path(custom_path).expanduser())

        # 2. Local directory project config
        paths_to_check.append(Path.cwd() / "code-rag.config")

        # 3. User configuration (XDG-style)
        # We prefer ~/.config/code-rag/config
        user_config_dir = Path.home() / ".config" / "code-rag"
        user_config_file = user_config_dir / "config"

        # Auto-create if it doesn't exist and we aren't testing
        if not user_config_file.exists():
            try:
                user_config_dir.mkdir(parents=True, exist_ok=True)
                user_config_file.write_text(DEFAULT_CONFIG, encoding="utf-8")
                # Only print via stderr to avoid corrupting MCP stdout if this happens during tool use
                # But Config might be initialized during module import, so be careful.
                # Safe to write, maybe skip print or print to stderr.
            except Exception:
                # working in a read-only fs or permission error, skip creation
                pass

        paths_to_check.append(user_config_file)

        # 4. Package source fallback (for dev envs, keeping .env here as it's gitignored)
        paths_to_check.append(Path(__file__).resolve().parent.parent.parent / ".env")

        # Load found files. override=False means:
        # - Shell vars > File vars
        # - We want specific files to override general ones?
        # load_dotenv defaults to override=False (don't overwrite system env).
        # But for file-vs-file, we want the first ones we check (files) to take precedence?
        # Actually load_dotenv adds to os.environ but doesn't overwrite if exists.
        # So we should load High Priority files FIRST.
        # Order above was: Custom -> Local -> User -> Package.
        # This is correct for load_dotenv(override=False).
        # The first file loaded sets the var. Subsequent files won't overwrite it.

        for path in paths_to_check:
            if path.is_file():
                load_dotenv(path)

    @staticmethod
    def _get_default_database_path() -> str:
        """Get the default database path in the user's cache directory."""
        # Use platformdirs logic for cross-platform cache directory
        if os.name == "nt":  # Windows
            cache_dir = Path(
                os.getenv("LOCALAPPDATA", Path.home() / "AppData" / "Local")
            )
        elif os.uname().sysname == "Darwin":  # macOS
            cache_dir = Path.home() / "Library" / "Caches"
        else:  # Linux and other Unix-like
            cache_dir = Path(os.getenv("XDG_CACHE_HOME", Path.home() / ".cache"))

        # Create code-rag subdirectory
        code_rag_cache = cache_dir / "code-rag"
        code_rag_cache.mkdir(parents=True, exist_ok=True)

        return str(code_rag_cache)

    def get_embedding_model(self) -> str:
        """Get the configured embedding model."""
        return self.embedding_model

    def get_database_type(self) -> str:
        """Get the configured database type."""
        return self.database_type

    def get_database_path(self) -> str:
        """Get the configured database path."""
        return self.database_path

    def get_chunk_size(self) -> int:
        """Get the configured chunk size."""
        return self.chunk_size

    def get_batch_size(self) -> int:
        """Get the configured batch size."""
        return self.batch_size

    def is_reranker_enabled(self) -> bool:
        """Get whether reranking is enabled."""
        return self.reranker_enabled

    def get_reranker_model(self) -> str:
        """Get the configured reranker model."""
        return self.reranker_model

    def get_reranker_multiplier(self) -> int:
        """Get the retrieval multiplier for reranking."""
        return self.reranker_multiplier

    def should_include_file_header(self) -> bool:
        """Get whether to include file headers in chunks."""
        return self.include_file_header

    def should_exclude_tests(self) -> bool:
        """Get whether to exclude test files from indexing."""
        return self.exclude_tests

    def get_additional_ignore_patterns(self) -> list[str]:
        """Get the additional ignore patterns."""
        return self.additional_ignore_patterns

    def get_log_level(self) -> str:
        """Get the configured log level."""
        return self.log_level

    def _get_int_env(self, name: str, default: int) -> int:
        """Parse integer env vars with a safe fallback."""
        value = os.getenv(name)
        if value is None:
            return default
        try:
            return int(value)
        except ValueError:
            return default

    def get_reindex_debounce_minutes(self) -> int:
        """Get the debounce interval for automatic reindexing in minutes."""
        return self.reindex_debounce_minutes

    def should_verify_changes_with_hash(self) -> bool:
        """Get whether to verify file changes with content hash."""
        return self.verify_changes_with_hash

    def get_model_idle_timeout(self) -> int:
        """Get the model idle timeout in seconds (default: 1800 = 30 minutes)."""
        return self.model_idle_timeout

    def is_shared_server_enabled(self) -> bool:
        """Get whether shared embedding server mode is enabled."""
        return self.shared_server_enabled

    def get_shared_server_port(self) -> int:
        """Get the shared embedding server port."""
        return self.shared_server_port

    def _sanitize_chunk_defaults(self) -> None:
        """Ensure chunk defaults form a sane pair when env vars are absent or invalid."""
        if self.chunk_size < 1:
            self.chunk_size = 1
