"""Configuration management for the code-rag tool."""

import os
from pathlib import Path

from dotenv import load_dotenv

DEFAULT_CONFIG = """# Configuration for code-rag
# This file is automatically generated. Modify as needed.

# Embedding model to use for generating vector embeddings
# Options:
# - nomic-ai/CodeRankEmbed (Recommended for code)
# - text-embedding-3-small (Requires OPENAI_API_KEY)
CODE_RAG_EMBEDDING_MODEL=nomic-ai/CodeRankEmbed

# Database type: 'chroma' or 'qdrant'
CODE_RAG_DATABASE_TYPE=chroma

# Database path (optional, defaults to OS-specific cache directory)
# Windows: %LOCALAPPDATA%\\code-rag
# macOS: ~/Library/Caches/code-rag
# Linux: ~/.cache/code-rag
# CODE_RAG_DATABASE_PATH=

# Chunk size in characters for splitting files
CODE_RAG_CHUNK_SIZE=1024

# Batch size for processing documents
CODE_RAG_BATCH_SIZE=32

# Whether to include file headers in chunks (true/false)
CODE_RAG_INCLUDE_FILE_HEADER=true

# Whether to exclude test files from indexing (true/false)
CODE_RAG_EXCLUDE_TESTS=false

# Additional ignore patterns (comma-separated list)
# Examples: *.log,*.tmp,custom_ignore_dir/
CODE_RAG_ADDITIONAL_IGNORE_PATTERNS=

# Whether reranking is enabled (true/false)
CODE_RAG_RERANKER_ENABLED=false

# Reranker model to use
CODE_RAG_RERANKER_MODEL=jinaai/jina-reranker-v3

# Type of reranking to perform
CODE_RAG_RERANKER_MULTIPLIER=2

# Security / Verification
CODE_RAG_VERIFY_CHANGES_WITH_HASH=true

# Shared Embedding Server
# Enables reusing the model across multiple calls to save memory
CODE_RAG_SHARED_SERVER=true
CODE_RAG_SHARED_SERVER_PORT=8199
"""


class Config:
    """Configuration handler for the code-rag application."""

    def __init__(self):
        """Initialize configuration from environment variables or defaults."""
        self._loaded_files: dict[Path, float] = {}
        # Keep track of initial environment to allow clean reloads
        self._initial_env = {
            k: v for k, v in os.environ.items() if k.startswith("CODE_RAG_")
        }
        self.reload()

    def reload(self) -> None:
        """Reload configuration from files and environment."""
        # Restore initial environment to ensure Shell > File precedence during reload
        for k in list(os.environ.keys()):
            if k.startswith("CODE_RAG_"):
                if k in self._initial_env:
                    os.environ[k] = self._initial_env[k]
                else:
                    del os.environ[k]

        self._load_config_files()
        self.embedding_model = os.getenv(
            "CODE_RAG_EMBEDDING_MODEL", "nomic-ai/CodeRankEmbed"
        )
        self.database_type = os.getenv("CODE_RAG_DATABASE_TYPE", "chroma")

        # Use cache directory if not explicitly set
        if "CODE_RAG_DATABASE_PATH" in os.environ:
            self.database_path = os.getenv("CODE_RAG_DATABASE_PATH")
        else:
            self.database_path = self._get_default_database_path()

        self.chunk_size = self._get_int_env("CODE_RAG_CHUNK_SIZE", 1024)
        self.batch_size = max(1, self._get_int_env("CODE_RAG_BATCH_SIZE", 32))

        # Chunking configuration
        self.include_file_header = os.getenv(
            "CODE_RAG_INCLUDE_FILE_HEADER", "true"
        ).lower() in ("true", "1", "yes")
        self.exclude_tests = os.getenv("CODE_RAG_EXCLUDE_TESTS", "false").lower() in (
            "true",
            "1",
            "yes",
        )

        # Additional ignore patterns (comma-separated)
        additional_ignore_str = os.getenv("CODE_RAG_ADDITIONAL_IGNORE_PATTERNS", "")
        self.additional_ignore_patterns = [
            pattern.strip()
            for pattern in additional_ignore_str.split(",")
            if pattern.strip()
        ]

        self._sanitize_chunk_defaults()

        # Reranker configuration
        self.reranker_enabled = os.getenv(
            "CODE_RAG_RERANKER_ENABLED", "true"
        ).lower() in ("true", "1", "yes")
        self.reranker_model = os.getenv(
            "CODE_RAG_RERANKER_MODEL", "jinaai/jina-reranker-v3"
        )
        self.reranker_multiplier = int(os.getenv("CODE_RAG_RERANKER_MULTIPLIER", "2"))

        # Logging configuration
        self.log_level = os.getenv("CODE_RAG_LOG_LEVEL", "INFO").upper()

        # Incremental indexing configuration
        self.reindex_debounce_minutes = self._get_int_env(
            "CODE_RAG_REINDEX_DEBOUNCE_MINUTES", 10
        )
        self.verify_changes_with_hash = os.getenv(
            "CODE_RAG_VERIFY_CHANGES_WITH_HASH", "true"
        ).lower() in ("true", "1", "yes")

        # Model idle timeout configuration (in seconds)
        # Default: 1800 seconds (30 minutes)
        self.model_idle_timeout = self._get_int_env("CODE_RAG_MODEL_IDLE_TIMEOUT", 1800)

        # Shared embedding server configuration
        # When enabled, MCP instances share a single model via HTTP server
        # Server auto-starts on demand and auto-terminates when idle
        self.shared_server_enabled = os.getenv(
            "CODE_RAG_SHARED_SERVER", "true"
        ).lower() in ("true", "1", "yes")
        self.shared_server_port = self._get_int_env("CODE_RAG_SHARED_SERVER_PORT", 8199)

    def has_changed(self) -> bool:
        """Check if any of the configuration files have changed on disk."""
        # Re-check the same paths we would check during loading
        paths_to_check = self._get_paths_to_check()

        for path in paths_to_check:
            if path.is_file():
                mtime = path.stat().st_mtime
                if path not in self._loaded_files or mtime > self._loaded_files[path]:
                    return True
            elif path in self._loaded_files:
                # File was there but now it's gone
                return True

        return False

    def _get_paths_to_check(self) -> list[Path]:
        """Get the list of config file paths to check in precedence order."""
        paths = []
        if custom_path := os.getenv("CODE_RAG_CONFIG_FILE"):
            paths.append(Path(custom_path).expanduser())
        paths.append(Path.cwd() / "code-rag.config")
        paths.append(Path.home() / ".config" / "code-rag" / "config")
        paths.append(Path(__file__).resolve().parent.parent.parent / ".env")
        return paths

    def _load_config_files(self) -> None:
        self._loaded_files = {}
        paths_to_check = self._get_paths_to_check()

        # Handle user config auto-creation if needed
        user_config_dir = Path.home() / ".config" / "code-rag"
        user_config_file = user_config_dir / "config"
        if not user_config_file.exists():
            try:
                user_config_dir.mkdir(parents=True, exist_ok=True)
                user_config_file.write_text(DEFAULT_CONFIG, encoding="utf-8")
            except Exception:
                pass

        for path in paths_to_check:
            if path.is_file():
                load_dotenv(path)
                self._loaded_files[path] = path.stat().st_mtime

    @staticmethod
    def _get_default_database_path() -> str:
        """Get the default database path in the user's cache directory."""
        # Use platformdirs logic for cross-platform cache directory
        if os.name == "nt":  # Windows
            cache_dir = Path(
                os.getenv("LOCALAPPDATA", Path.home() / "AppData" / "Local")
            )
        elif os.uname().sysname == "Darwin":  # macOS
            cache_dir = Path.home() / "Library" / "Caches"
        else:  # Linux and other Unix-like
            cache_dir = Path(os.getenv("XDG_CACHE_HOME", Path.home() / ".cache"))

        # Create code-rag subdirectory
        code_rag_cache = cache_dir / "code-rag"
        code_rag_cache.mkdir(parents=True, exist_ok=True)

        return str(code_rag_cache)

    def get_embedding_model(self) -> str:
        """Get the configured embedding model."""
        return self.embedding_model

    def get_database_type(self) -> str:
        """Get the configured database type."""
        return self.database_type

    def get_database_path(self) -> str:
        """Get the configured database path."""
        return self.database_path

    def get_chunk_size(self) -> int:
        """Get the configured chunk size."""
        return self.chunk_size

    def get_batch_size(self) -> int:
        """Get the configured batch size."""
        return self.batch_size

    def is_reranker_enabled(self) -> bool:
        """Get whether reranking is enabled."""
        return self.reranker_enabled

    def get_reranker_model(self) -> str:
        """Get the configured reranker model."""
        return self.reranker_model

    def get_reranker_multiplier(self) -> int:
        """Get the retrieval multiplier for reranking."""
        return self.reranker_multiplier

    def should_include_file_header(self) -> bool:
        """Get whether to include file headers in chunks."""
        return self.include_file_header

    def should_exclude_tests(self) -> bool:
        """Get whether to exclude test files from indexing."""
        return self.exclude_tests

    def get_additional_ignore_patterns(self) -> list[str]:
        """Get the additional ignore patterns."""
        return self.additional_ignore_patterns

    def get_log_level(self) -> str:
        """Get the configured log level."""
        return self.log_level

    def _get_int_env(self, name: str, default: int) -> int:
        """Parse integer env vars with a safe fallback."""
        value = os.getenv(name)
        if value is None:
            return default
        try:
            return int(value)
        except ValueError:
            return default

    def get_reindex_debounce_minutes(self) -> int:
        """Get the debounce interval for automatic reindexing in minutes."""
        return self.reindex_debounce_minutes

    def should_verify_changes_with_hash(self) -> bool:
        """Get whether to verify file changes with content hash."""
        return self.verify_changes_with_hash

    def get_model_idle_timeout(self) -> int:
        """Get the model idle timeout in seconds (default: 1800 = 30 minutes)."""
        return self.model_idle_timeout

    def is_shared_server_enabled(self) -> bool:
        """Get whether shared embedding server mode is enabled."""
        return self.shared_server_enabled

    def get_shared_server_port(self) -> int:
        """Get the shared embedding server port."""
        return self.shared_server_port

    def _sanitize_chunk_defaults(self) -> None:
        """Ensure chunk defaults form a sane pair when env vars are absent or invalid."""
        if self.chunk_size < 1:
            self.chunk_size = 1
